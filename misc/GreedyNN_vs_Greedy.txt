=================================================================
GREEDY NN (Nearest Neighbor) vs GREEDY (Best-First Search)
=================================================================

GREEDY NN - Fast Nearest Neighbor Algorithm
--------------------------------------------

WHAT IT IS:
Greedy NN is a simple, fast heuristic algorithm that always moves the 
robot to the nearest dirt cell and sucks it, repeating until all dirt 
is cleaned.

HOW IT WORKS:
1. Look at all remaining dirt cells
2. Calculate Manhattan distance to each: |x1-x2| + |y1-y2|
3. Choose the CLOSEST dirt cell
4. Move robot there (horizontal moves first, then vertical)
5. Suck the dirt
6. Repeat until no dirt remains

EXAMPLE (5x5 grid):
Robot at (0,0), dirt at (2,1) and (4,4)
- Nearest: (2,1) with distance 3
- Move: RIGHT, RIGHT, DOWN → SUCK
- Next nearest: (4,4) with distance 6
- Move: RIGHT, RIGHT, DOWN, DOWN, DOWN → SUCK
- Done!

TIME COMPLEXITY: O(k² · n²)
  where k = number of dirt cells, n = grid size
  For 10x10 with 30 dirt: ~900 steps in < 50ms

GUARANTEES:
✓ Always completes (never gets stuck)
✓ Fast execution even on huge boards
✗ NOT optimal (path can be 1.5-2x longer than optimal)


GREEDY (Best-First Search)
---------------------------

WHAT IT IS:
Greedy is a graph search algorithm that explores states by always
expanding the node with the LOWEST heuristic value (estimated cost
to goal), ignoring the actual path cost so far.

HOW IT WORKS:
1. Start with initial state in priority queue (ordered by h(n))
2. Pop state with lowest h(n) value
3. If goal reached, return path
4. Expand all successor states (move actions + suck actions)
5. Add unexplored successors to queue with their h(n) values
6. Repeat

HEURISTIC USED:
h(state) = Manhattan_distance_to_nearest_dirt + (dirt_count - 1)

EXAMPLE STATE SPACE (5x5 grid):
Initial: Robot(0,0), Dirt{(2,1), (4,4)} → h = 3 + 1 = 4
After RIGHT: Robot(1,0), Dirt{(2,1), (4,4)} → h = 2 + 1 = 3 ← Lower!
After RIGHT,RIGHT: Robot(2,0), Dirt{(2,1), (4,4)} → h = 1 + 1 = 2
...explores entire state space...

TIME COMPLEXITY: O(b^d) exponential!
  where b = branching factor (~5), d = solution depth
  States = n² × 2^k (position × dirt combinations)
  For 10x10 with 30 dirt: 100 × 2^30 = 107 BILLION states!

GUARANTEES:
✗ May timeout on large boards (>6x6)
✗ NOT optimal (only considers heuristic, not actual cost)
✓ Often finds good solutions when it completes


KEY DIFFERENCES
---------------

| Aspect           | Greedy NN              | Greedy (Best-First)    |
|------------------|------------------------|------------------------|
| Type             | Constructive heuristic | Graph search algorithm |
| Search Space     | None (direct moves)    | Exponential states     |
| Complexity       | O(k²·n²) polynomial    | O(b^d) exponential     |
| Max Board Size   | Any size works         | ~6x6 before timeout    |
| Speed            | < 100ms on 10x10       | 15s timeout on 8x8     |
| Optimality       | No (1.5-2x optimal)    | No (greedy heuristic)  |
| Completeness     | Always finds solution  | May timeout            |

WHY THE NAME CONFUSION?
-----------------------
Both are called "Greedy" because they make locally optimal choices:
- Greedy NN: Greedy choice of NEAREST dirt (simple distance)
- Greedy Best-First: Greedy choice of BEST heuristic state (complex)

But they're fundamentally different algorithms!

WHEN TO USE EACH
----------------

Use GREEDY NN when:
✓ Board size ≥ 7x7
✓ Need guaranteed completion
✓ Speed is critical
✓ Sub-optimal paths are acceptable

Use GREEDY (Best-First) when:
✓ Board size ≤ 6x6
✓ Want better solution quality than NN
✓ Can tolerate longer search time
✗ Use A* instead if you want optimality!

RECOMMENDATION FOR VACUUM WORLD
--------------------------------
For boards larger than 6x6, ALWAYS use Greedy NN.
The exponential state space makes graph search algorithms 
(BFS, DFS, UCS, Greedy, even A*) impractical.

Greedy NN sacrifices optimality for guaranteed fast completion,
which is the right trade-off for large problem instances.
